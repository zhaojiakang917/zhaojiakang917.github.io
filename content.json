{"meta":{"title":"Read the fucking ♂ source code","subtitle":"每天学习新姿势","description":"不定时更新技术，游戏，阿尼妹脱","author":"Yori Zhao(赵佳康)","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-04-26T08:45:40.000Z","updated":"2019-03-28T13:06:27.592Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"新日♂暮里","date":"2018-04-27T02:38:29.000Z","updated":"2019-03-28T13:06:27.588Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-27T02:35:03.000Z","updated":"2019-03-28T13:06:27.588Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android免root获取shell级权限实现静默卸载安装","slug":"Android免root获取shell级权限实现静默卸载安装","date":"2019-04-03T04:16:20.000Z","updated":"2019-04-13T09:17:19.912Z","comments":true,"path":"2019/04/03/Android免root获取shell级权限实现静默卸载安装/","link":"","permalink":"http://yoursite.com/2019/04/03/Android免root获取shell级权限实现静默卸载安装/","excerpt":"方案分析市面上实现这种方案最早的应用应该是”黑阈”，我们在使用的时候需要开启调试模式，然后通过adb或者注入器注入主服务，才可以使用后台管制以及其他高级权限的功能。所以本方案也是基于这种注入服务的方式，来实现各种需要高级权限的功能 Shell级权限的服务这种方案的关键点是这个拥有shell级权限的服务，Android提供了app_process指令供我们启动一个进程，我们可以通过该指令起一个Java服务，如果是通过shell执行的，该服务会从/system/bin/sh fork出来，并且拥有shell级权限","text":"方案分析市面上实现这种方案最早的应用应该是”黑阈”，我们在使用的时候需要开启调试模式，然后通过adb或者注入器注入主服务，才可以使用后台管制以及其他高级权限的功能。所以本方案也是基于这种注入服务的方式，来实现各种需要高级权限的功能 Shell级权限的服务这种方案的关键点是这个拥有shell级权限的服务，Android提供了app_process指令供我们启动一个进程，我们可以通过该指令起一个Java服务，如果是通过shell执行的，该服务会从/system/bin/sh fork出来，并且拥有shell级权限 这里我写了一个service.dex服务来测试一下，并通过shell启动它12345// 先将service.dex push至Android设备adb push service.dex /data/local/tmp/// 然后通过app_process启动，并指定一个名词adb shell nohup app_process -Djava.class.path=/data/local/tmp/server.dex /system/bin --nice-name=club.syachiku.hackrootservice shellService.Main 然后再看看该服务的信息12345// 列出所有正在运行的服务adb shell ps// 找到服务名为club.syachiku.hackrootservice的服务shell 24154 1 777484 26960 ffffffff b6e7284c S club.syachiku.hackrootservice 可以看到该服务pid为24154，ppid为1，也说明该服务是从/system/bin/sh fork出来的1234567891011121314151617181920212223242526272829303132333435363738394041// 查看该服务具体信息adb shell cat /proc/24154/statusName: mainState: S (sleeping)Tgid: 24154Pid: 24154PPid: 1TracerPid: 0Uid: 2000 2000 2000 2000Gid: 2000 2000 2000 2000FDSize: 32Groups: 1004 1007 1011 1015 1028 3001 3002 3003 3006VmPeak: 777484 kBVmSize: 777484 kBVmLck: 0 kBVmPin: 0 kBVmHWM: 26960 kBVmRSS: 26960 kBVmData: 11680 kBVmStk: 8192 kBVmExe: 12 kBVmLib: 52812 kBVmPTE: 134 kBVmSwap: 0 kBThreads: 13SigQ: 0/6947SigPnd: 0000000000000000ShdPnd: 0000000000000000SigBlk: 0000000000001204SigIgn: 0000000000000001SigCgt: 00000002000094f8CapInh: 0000000000000000CapPrm: 0000000000000000CapEff: 0000000000000000CapBnd: 00000000000000c0Seccomp: 0Cpus_allowed: fCpus_allowed_list: 0-3voluntary_ctxt_switches: 18nonvoluntary_ctxt_switches: 76 可以看到Uid，Gid为2000，就是shell的Uid 开始吧(本方案也需开启调试模式)分析了app_process的可行性，我们可以给出一个方案，通过app_process启动一个socket服务，然后让我们的App与该服务通信，来代理App做一些见不得人需要shell级权限的事情，比如静默卸载，安装，全局广播等等 新建工程这里我们新建一个名为hack-root的工程 编写socket服务然后在代码目录下新建一个shellService包，新建一个Main入口类，我们先输出一些测试代码，来测试是否执行成功 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"*****************hack server starting****************\"); &#125;&#125; 首先执行./gradlew buildDebug打包，然后.apk改成.rar解压出classes.dex文件，然后将该文件push至你的Android设备比如/sdcard/ 然后使用app_process指令执行该服务 1adb shell app_process -Djava.class.path=/sdcard/classes.dex /system/bin shellService.Main 如果控制台输出Abort应该是一些基本的路径问题，稍作仔细检查一下，成功执行后会看到我们的打印的日志 运行测试没问题了就开写socket服务吧12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; // 利用looper让线程循环 Looper.prepareMainLooper(); System.out.println(\"*****************hack server starting****************\"); // 开一个子线程启动服务 new Thread(new Runnable() &#123; @Override public void run() &#123; new SocketService(new SocketService.SocketListener() &#123; @Override public String onMessage(String msg) &#123; // 接收客户端传过来的消息 return resolveMsg(msg); &#125; &#125;); &#125; &#125;).start(); Looper.loop(); &#125; private static String resolveMsg(String msg) &#123; // 执行客户端传过来的消息并返回执行结果 ShellUtil.ExecResult execResult = ShellUtil.execute(\"pm uninstall \" + msg); return execResult.getMessage(); &#125;&#125; SocketServer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class SocketService &#123; private final int PORT = 10500; private SocketListener listener; public SocketService(SocketListener listener) &#123; this.listener = listener; try &#123; // 利用ServerSocket类启动服务，然后指定一个端口 ServerSocket serverSocket = new ServerSocket(PORT); System.out.println(\"server running \" + PORT + \" port\"); ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); // 新建一个线程池用来并发处理客户端的消息 ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, 10, 5000, TimeUnit.MILLISECONDS, queue ); while (true) &#123; Socket socket = serverSocket.accept(); // 接收到新消息 executor.execute(new processMsg(socket)); &#125; &#125; catch (Exception e) &#123; System.out.println(\"SocketServer create Exception:\" + e); &#125; &#125; class processMsg implements Runnable &#123; Socket socket; public processMsg(Socket s) &#123; socket = s; &#125; public void run() &#123; try &#123; // 通过流读取内容 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = bufferedReader.readLine(); System.out.println(\"server receive: \" + line); PrintWriter printWriter = new PrintWriter(socket.getOutputStream()); String repeat = listener.onMessage(line); System.out.println(\"server send: \" + repeat); // 服务端返回给客户端的消息 printWriter.print(repeat); printWriter.flush(); printWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; System.out.println(\"socket connection error：\" + e.toString()); &#125; &#125; &#125; public interface SocketListener&#123; // 通话消息回调 String onMessage(String text); &#125;&#125; ShellUtil 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class ShellUtil &#123; private static final String COMMAND_LINE_END = \"\\n\"; private static final String COMMAND_EXIT = \"exit\\n\"; // 单条指令 public static ExecResult execute(String command) &#123; return execute(new String[] &#123;command&#125;); &#125; // 多条指令重载方法 private static ExecResult execute(String[] commands) &#123; if (commands == null || commands.length == 0) &#123; return new ExecResult(false, \"empty command\"); &#125; int result = -1; Process process = null; DataOutputStream dataOutputStream = null; BufferedReader sucResult = null, errResult = null; StringBuilder sucMsg = null, errMsg = null; try &#123; // 获取shell级别的process process = Runtime.getRuntime().exec(\"sh\"); dataOutputStream = new DataOutputStream(process.getOutputStream()); for (String command : commands) &#123; if (command == null) continue; System.out.println(\"execute command: \" + command); // 执行指令 dataOutputStream.write(command.getBytes()); dataOutputStream.writeBytes(COMMAND_LINE_END); // 刷新 dataOutputStream.flush(); &#125; dataOutputStream.writeBytes(COMMAND_EXIT); dataOutputStream.flush(); result = process.waitFor(); sucMsg = new StringBuilder(); errMsg = new StringBuilder(); sucResult = new BufferedReader(new InputStreamReader(process.getInputStream())); errResult = new BufferedReader(new InputStreamReader(process.getErrorStream())); String s; while ((s = sucResult.readLine()) != null) &#123; sucMsg.append(s); &#125; while ((s = errResult.readLine()) != null) &#123; errMsg.append(s); &#125; &#125; catch (IOException | InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 关闭资源，防止内存泄漏 assert dataOutputStream != null; dataOutputStream.close(); assert sucResult != null; sucResult.close(); assert errResult != null; errResult.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; process.destroy(); &#125; ExecResult execResult; if (result == 0) &#123; execResult = new ExecResult(true, sucMsg.toString()); &#125; else &#123; execResult = new ExecResult(false, errMsg.toString()); &#125; // 返回执行结果 return execResult; &#125; public static class ExecResult &#123; private boolean success; private String message; public ExecResult(boolean success, String message) &#123; this.success = success; this.message = message; &#125; public boolean getSuccess() &#123; return this.success; &#125; public String getMessage() &#123; return this.message; &#125; &#125;&#125; 一个简易的socket服务就搭建好了，可以用来接收客户端传过来的指令并且执行然后返回结果 编写客户端首先编写一个socketClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SocketClient &#123; private final String TAG = \"HackRoot SocketClient\"; private final int PORT = 10500; private SocketListener listener; private PrintWriter printWriter; public SocketClient(final String cmd, SocketListener listener) &#123; this.listener = listener; new Thread(new Runnable() &#123; @Override public void run() &#123; Socket socket = new Socket(); try &#123; // 与hackserver建立连接 socket.connect(new InetSocketAddress(\"127.0.0.1\", PORT), 3000); socket.setSoTimeout(3000); printWriter = new PrintWriter(socket.getOutputStream(), true); Log.d(TAG, \"client send: \" + cmd); // 发送指令 printWriter.println(cmd); printWriter.flush(); // 读取服务端返回 readServerData(socket); &#125; catch (IOException e) &#123; Log.d(TAG, \"client send fail: \" + e.getMessage()); e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void readServerData(final Socket socket) &#123; try &#123; InputStreamReader ipsReader = new InputStreamReader(socket.getInputStream()); BufferedReader bfReader = new BufferedReader(ipsReader); String line = null; while ((line = bfReader.readLine()) != null) &#123; Log.d(TAG, \"client receive: \" + line); listener.onMessage(line); &#125; // 释放资源 ipsReader.close(); bfReader.close(); printWriter.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; interface SocketListener &#123; void onMessage(String msg); &#125;&#125; 然后UI组件相关的事件，我们暂时只实现一个静默卸载App的功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; private TextView textView; private ScrollView scrollView; private EditText uninsTxtInput; private Button btnUnins; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnUnins = findViewById(R.id.btn_uninstall); uninsTxtInput = findViewById(R.id.pkg_input); textView = findViewById(R.id.tv_output); scrollView = findViewById(R.id.text_container); btnUnins.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; sendMessage(uninsTxtInput.getText().toString()); &#125; &#125;); &#125; private void sendMessage(String msg) &#123; new SocketClient(msg, new SocketClient.SocketListener() &#123; @Override public void onMessage(String msg) &#123; showOnTextView(msg); &#125; &#125;); &#125; private void showOnTextView(final String msg) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; String baseText = textView.getText().toString(); if (baseText != null) &#123; textView.setText(baseText + \"\\n\" + msg); &#125; else &#123; textView.setText(msg); &#125; scrollView.smoothScrollTo(0, scrollView.getHeight()); &#125; &#125;); &#125;&#125; 布局代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;EditText android:id=\"@+id/pkg_input\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginEnd=\"8dp\" android:layout_marginStart=\"8dp\" android:layout_marginTop=\"8dp\" android:hint=\"input package name\" app:layout_constraintEnd_toStartOf=\"@+id/btn_uninstall\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;Button android:id=\"@+id/btn_uninstall\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginEnd=\"8dp\" android:layout_marginTop=\"8dp\" android:text=\"uninstall\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;ScrollView android:id=\"@+id/text_container\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_marginBottom=\"8dp\" android:layout_marginEnd=\"8dp\" android:padding=\"10dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/pkg_input\"&gt; &lt;TextView android:id=\"@+id/tv_output\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/ScrollView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 代码相关的工作基本完工，一个简单的，实现了静默卸载Demo就完成了 打包测试 ./gradlew assembleRelease 打出apk 后缀改成.rar解压出classes.dex 将classes.dex push至/data/local/tmp/ 执行服务 前台执行： 12// 拔掉数据线会终止服务adb shell app_process -Djava.class.path=/data/local/tmp/classes.dex /system/bin shellService.Main 后台执行： 12// 会一直运行除非手动kill pid或者重启设备adb shell nohup app_process -Djava.class.path=/data/local/tmp/classes.dex /system/bin --nice-name=$&#123;serviceName&#125; shellService.Main 安装apk，输入要卸载的包名，点击UNINSTALL进行静默卸载 完整项目https://github.com/zjkhiyori/hack-root 欢迎fork || star 技术参考感谢下列开源作者 android-common Fairy app_process-shell-use","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"一个NodeJS生成excel表格的小demo","slug":"一个NodeJS生成excel表格的小demo","date":"2018-12-14T03:52:35.000Z","updated":"2019-03-28T13:06:27.566Z","comments":true,"path":"2018/12/14/一个NodeJS生成excel表格的小demo/","link":"","permalink":"http://yoursite.com/2018/12/14/一个NodeJS生成excel表格的小demo/","excerpt":"环境准备已经2018年了，广大人民群众基本都用上es6了，所以这里也配一下es6的环境 新建工程，创建一个package.json123456&#123; \"name\": \"projectName\", \"version\": \"1.0.0\", \"devDependencies\": &#123;&#125;, \"dependencies\": &#123;&#125;&#125;","text":"环境准备已经2018年了，广大人民群众基本都用上es6了，所以这里也配一下es6的环境 新建工程，创建一个package.json123456&#123; \"name\": \"projectName\", \"version\": \"1.0.0\", \"devDependencies\": &#123;&#125;, \"dependencies\": &#123;&#125;&#125; node版本建议不要太低，低版本对es6的兼容性不好，我这里使用的是8.9.0 然后安装babel1234yarn add babel-cli// 老版本babel-preset-2015已经废弃yarn add babel-preset-env 然后再写几句es6测试一下123456789101112131415161718// 新建一个诗人类class Poet &#123; poem(...poemText) &#123; console.log(poemText); &#125;&#125;epxort default Poet;//新建一个Test.js类import Poet from './Poet';let poet = new Poet();poet.poem('苟', '岂');// 然后用babel node指令跑一下Test.jsbabel-node Test.js// [ '苟', '岂' ]// 成功念出我想念的诗 es6环境就ok了 生成excel我这里用的是一个随便找的库excel-export，这个库的issue已经有人在喊”This project is DEAD!!!” 无视他继续安装1yarn add excel-export 使用方法我这里也只是简单用一下基本功能，高级用法还是直接看该库的文档 1234567891011121314151617181920const conf = &#123;&#125;;// 定义sheet名称conf.name = \"DBData\";// 定义列的名称以及数据类型conf.cols = [&#123; caption:'Name', type:'string'&#125;,&#123; caption:'Type', type:'string'&#125;];// 定义row的数据conf.rows = ['Tom', \"String\"];// execute方法生成文件源数据const result = nodeExcel.execute(conf);// fs将文件写到内存fs.writeFile(`$&#123;__dirname&#125;/test.xlsx`, result, 'binary', (err) =&gt; &#123; err ? console.log(err) : null;&#125;); Demo的代码地址ExcelGenerator","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"shadowsocks服务搭建以及全局代理","slug":"shadowsocks服务搭建以及全局代理","date":"2018-11-13T07:40:10.000Z","updated":"2019-03-28T13:06:27.558Z","comments":true,"path":"2018/11/13/shadowsocks服务搭建以及全局代理/","link":"","permalink":"http://yoursite.com/2018/11/13/shadowsocks服务搭建以及全局代理/","excerpt":"最近又有一台服务器被GFW给干掉了，又得掏腰包买服务器跟搭建环境了，这次记录一下方便以后翻出来看吧","text":"最近又有一台服务器被GFW给干掉了，又得掏腰包买服务器跟搭建环境了，这次记录一下方便以后翻出来看吧 项目地址: shadowsocks（可以看到打开是个空项目，分支切换到master就可以看到原始项目了，据说是作者被请喝茶才出此下策？这些人这么好忽悠的吗？） 因为本人对科学上网有一定需求，公司邮箱也用Gmail，手机也用google全家桶，所以一般都会配备至少两台服务器，如果跟我一样有需求的，建议也至少配备两台 关于服务器购买就不多说了，我用的是这个Aplpharacks，一台VPS 512m或者256m内存的完全够用，我有一台早期买的128m的，大部分时间速度比其他几台要快，可能是哥伦比亚机房的原因？不过现在已经没得卖了，现在主要卖的都是洛杉矶机房，稳定性一般，网络好峰值可达4m/s，网络差的时候基本瘫痪 优点：便宜，因为偶尔可能会中奖ip被GFW封，所以买个便宜的封了也不心疼 缺点：不稳定 服务搭建及部署搭建过程很简单，首先下载基础包跟python包管理器 我一般都是用Ubuntu，这里以Ubuntu为例123456789apt-get install python-pip// 如果有 E: Unable to locate package python-pip 错误// 执行一下 sudo apt-get update 再install// 安装gitsudo apt-get install git// 安装ss基础包pip install git+https://github.com/shadowsocks/shadowsocks.git@master 安装好了键入1ssserver -h 有相应指令帮助提示就表面基础包已经ok 然后就是编辑配置信息12345678910111213141516171819202122232425262728// 新建一个json配置文件touch ~/shadowsocks.json// 然后编辑vim ~/shadowsocks.json&#123; // 你的服务器ip \"server\": \"*.*.*.*\", // 配置多个端口及密码， \"port_password\": &#123; \"8080\": \"hello\", \"8081\": \"hello\", \"8082\": \"hello\", \"8083\": \"hello\", \"8084\": \"hello\", \"8085\": \"hello\", \"443\": \"hello\" &#125;, // 单个端口配置 \"server_port\":8388, \"password\": \"hello\", \"local_address\": \"127.0.0.1\", \"local_port\": 1080, \"timeout\": 500, \"method\": \"rc4-md5\"&#125; 这里强烈建议多开几个端口备用，因为使用中发现GFW会对端口进行干扰，如果只配置了一个端口，被干扰后整台服务器无法使用，所以多开几个端口备用，一个端口失效了换其他端口试试 弄完配置文件就可以部署服务了 执行指令1234前台启动方式ssserver -c ~/shadowsocks.json后台启动方式ssserver -c ~/shadowsocks.json -d start 执行完后可以看看端口使用情况1netstat -tunpl 可以看到刚才配置的端口使用情况，能看到刚才配置的端口就表明部署ok了，剩下就是客户端的事情了 客户端建议下载ShadowsocksX-NG 客户端配置好应该就能上网了，注意加密方式与服务端保持一致 全局代理因为chrome支持http转socks5协议，而终端不支持，所以终端无法走socks5协议，此时我们就需要一个全局代理，我用的是Proxifier，价格40刀，软件卖的比较贵，有条件的同学还请支持正版，网上也有很多破解资源 打开代理配置，增加一条配置 这里填入你shadowsocksX-NG的本地监听地址以及端口然后打开rules，default设置为下图然后回Proxifier首页将应用设置为gobal（默认为NONE） 此时connection栏目就能监控到你的网络请求，控制台也能科学上网了 然后我就可以登录我可怜的，才用了几个月的，被封禁的服务器了TAT。。。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"extra","slug":"extra","permalink":"http://yoursite.com/tags/extra/"}]},{"title":"手撸排序：快速排序","slug":"手撸排序：快速排序","date":"2018-10-25T07:27:36.000Z","updated":"2019-03-28T13:06:27.580Z","comments":true,"path":"2018/10/25/手撸排序：快速排序/","link":"","permalink":"http://yoursite.com/2018/10/25/手撸排序：快速排序/","excerpt":"核心思想首先算法理解了主要思想，那么代码实现也是信手拈来 快排分以下三步：","text":"核心思想首先算法理解了主要思想，那么代码实现也是信手拈来 快排分以下三步： 找基准：挑一个基准数用来分割当前数组，我们称该数为”基准”(pivot) 分割：把数组里小于”基准”的数放到左边，遍历一遍操作后数组就分割好了，最麻烦的也是这步分割操作了 递归：对分割后的数组重复第一二步，直到最后数组长度为1或0，就代表已经排好可以返回了 实例分析首先我们用lodash创建一个随机数组12_.shuffle([1,2,3,4,5,6,7,8,9,10])// [2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ] 现在将它进行排序 首先选取基准数，我们就直接取最后一位作为基准数，左起设一个index值记录替换次数，每替换一次index自增1 然后从左至右开始遍历1234567891011121314151617181920212223242526272829303132[2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ]// 6 &gt; 2替换下标为0，0的两个数，index自增1，[2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ]// 6 &gt; 3替换下标为1，1的两个数，index自增1[2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ]// 6 &gt; 4替换下标为2，2的两个数，index自增1[2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ]// 6 &gt; 1替换下标为3，3的两个数，index自增1[2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ]// 6 &lt; 7不替换，index为4不变[2, 3, 4, 1, 7, 5, 8, 10, 9, 6 ]// 6 &gt; 5替换下标为4, 5的两个数，index自增1[2, 3, 4, 1, 5, 7, 8, 10, 9, 6 ]// 6 &lt; 8不替换，index为5不变[2, 3, 4, 1, 5, 7, 8, 10, 9, 6 ]// 6 &lt; 10不替换，index为5不变[2, 3, 4, 1, 5, 7, 8, 10, 9, 6 ]// 6 &lt; 9不替换，index为5不变[2, 3, 4, 1, 5, 6, 8, 10, 9, 7 ]// 遍历结束替换pivot与index下标的值，这样就分割出了两个数组[2, 3, 4, 1, 5][8, 10, 9, 7]// 然后再分别将这两个数组进行重复上述操作 有了上述思路就可以开始撸代码了1234567891011121314151617181920212223242526272829303132// 定义交换逻辑function swap(arr, i, j) &#123; const temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;// 定义分割逻辑function partition(arr, left, right) &#123; const pivot = arr[right]; let index = left; for (let i = left; i &lt; right; i++) &#123; if (pivot &gt; arr[i]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, right, index); return index;&#125;function sort(arr, left, right) &#123; if (left &gt; right) return; const index = partition(arr, left, right); sort(arr, left, index - 1); sort(arr, index + 1, right);&#125;function quick_sort(arr) &#123; sort(arr, 0, arr.length - 1); return arr&#125; 代码可能较其他方法冗余，个人认为这是思路最清晰的写法 测试然后加一些测试代码123456789101112const _ = require('lodash');const arr = _.shuffle([1,2,3,4,5,6,7,8,9,10]);console.log(arr);console.log(quick_sort(arr));// [ 8, 3, 9, 4, 7, 1, 6, 2, 5, 10 ]// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]// [ 2, 8, 4, 3, 9, 5, 1, 10, 6, 7 ]// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]// [ 10, 7, 8, 4, 6, 1, 2, 9, 3, 5 ]// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] 测试ok","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"关于Android提取、备份APK","slug":"关于Android提取、备份APK","date":"2018-07-10T07:04:22.000Z","updated":"2019-03-28T13:06:27.574Z","comments":true,"path":"2018/07/10/关于Android提取、备份APK/","link":"","permalink":"http://yoursite.com/2018/07/10/关于Android提取、备份APK/","excerpt":"通过adb提取APKAndroid提取apk有两种途径，一种是通过adb12345678910// 列出所有安装包adb shell pm list package// 找到你需要提取的包名，然后获取路径adb shell pm path packageName// 输出路径后拷贝或者pull到你的电脑adb pull apkPath ~/Download// 某些设备可能需要root权限才能访问这个path路径","text":"通过adb提取APKAndroid提取apk有两种途径，一种是通过adb12345678910// 列出所有安装包adb shell pm list package// 找到你需要提取的包名，然后获取路径adb shell pm path packageName// 输出路径后拷贝或者pull到你的电脑adb pull apkPath ~/Download// 某些设备可能需要root权限才能访问这个path路径 另一种方法就是通过编写App进行提取/备份apk 通过编写App提取/备份APK这种方法主要通过packageManager来获取系统的所有应用信息packageInfo，里面包含了应用路径，包名，应用名等信息，然后根据路径进行拷贝以及备份 ApkExtractor工具个人通过闲暇时间写的一个apk提取工具，使用React Native构建，数据框架使用Mobx，欢迎下载体验 项目地址：https://github.com/zjkhiyori/ApkExtractorRN","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"React Native for Android 源码解析：Reload, Debug JS Remotely具体做了什么？","slug":"React Native for Android 源码解析：Reload, Debug JS Remotely做了什么？","date":"2018-05-15T10:54:54.000Z","updated":"2019-03-28T13:06:27.556Z","comments":true,"path":"2018/05/15/React Native for Android 源码解析：Reload, Debug JS Remotely做了什么？/","link":"","permalink":"http://yoursite.com/2018/05/15/React Native for Android 源码解析：Reload, Debug JS Remotely做了什么？/","excerpt":"Reload, debug js remotely罪恶滔天，弄的百姓怨声载道最近使用0.54.0版本开发有个调试的bug非常恶心，debug js remotely总是抛1234DeltaPatcher.js:58 Uncaught (in promise) Error: DeltaPatcher should receive a fresh Delta when being initialized at DeltaPatcher.applyDelta (DeltaPatcher.js:58) at deltaUrlToBlobUrl (deltaUrlToBlobUrl.js:34) at &lt;anonymous&gt; 想再次debug就得杀掉进程重新打开，官方解释在0.55版本会修复此问题，看了下pr改动都是js代码，随即更新版本修复此问题。若想以后碰到类似框架性的问题，想要自己能有排错纠错能力，还是老老实实啃源码吧","text":"Reload, debug js remotely罪恶滔天，弄的百姓怨声载道最近使用0.54.0版本开发有个调试的bug非常恶心，debug js remotely总是抛1234DeltaPatcher.js:58 Uncaught (in promise) Error: DeltaPatcher should receive a fresh Delta when being initialized at DeltaPatcher.applyDelta (DeltaPatcher.js:58) at deltaUrlToBlobUrl (deltaUrlToBlobUrl.js:34) at &lt;anonymous&gt; 想再次debug就得杀掉进程重新打开，官方解释在0.55版本会修复此问题，看了下pr改动都是js代码，随即更新版本修复此问题。若想以后碰到类似框架性的问题，想要自己能有排错纠错能力，还是老老实实啃源码吧 Reload首先看看Reload，先从Activity下手，初始demo里MainActivity继承了ReactActivity，RN工程的初始化，加载jsbundle的触发都在这个ReactActivity中，然后具体业务逻辑又交给了它的代理类ReactActivityDelegate，里面做了初始化RN框架逻辑，框架初始化的流程先不管，主要看看reload流程 onKeyUp123456789101112131415public boolean onKeyUp(int keyCode, KeyEvent event) &#123; if (getReactNativeHost().hasInstance() &amp;&amp; getReactNativeHost().getUseDeveloperSupport()) &#123; if (keyCode == KeyEvent.KEYCODE_MENU) &#123; getReactNativeHost().getReactInstanceManager().showDevOptionsDialog(); return true; &#125; boolean didDoubleTapR = Assertions.assertNotNull(mDoubleTapReloadRecognizer) .didDoubleTapR(keyCode, getPlainActivity().getCurrentFocus()); if (didDoubleTapR) &#123; getReactNativeHost().getReactInstanceManager().getDevSupportManager().handleReloadJS(); return true; &#125; &#125; return false; &#125; ReactActivity中侦听了物理按键，在keyCode为82即menu按键的时候，获取了RN主要的管理类ReactInstanceManager，然后调起了调试框DevOptionsDialog，具体业务逻辑在DevSupportManagerImpl这个类中，还可以看到有另外一个doubleTapR操作可以直接进行reload jsbundle，继续跟到DevSupportManagerImpl中，这里定义了调试dialog，跟到R.string.catalyst_reloadjs这个事件，触发了handleReloadJS，reload的流程入口就在这个方法中 handleReloadJS1234567891011121314151617181920212223242526@Override public void handleReloadJS() &#123; UiThreadUtil.assertOnUiThread(); ReactMarker.logMarker( ReactMarkerConstants.RELOAD, mDevSettings.getPackagerConnectionSettings().getDebugServerHost()); // dismiss redbox if exists hideRedboxDialog(); if (mDevSettings.isRemoteJSDebugEnabled()) &#123; PrinterHolder.getPrinter() .logMessage(ReactDebugOverlayTags.RN_CORE, \"RNCore: load from Proxy\"); mDevLoadingViewController.showForRemoteJSEnabled(); mDevLoadingViewVisible = true; reloadJSInProxyMode(); &#125; else &#123; PrinterHolder.getPrinter() .logMessage(ReactDebugOverlayTags.RN_CORE, \"RNCore: load from Server\"); String bundleURL = mDevServerHelper.getDevServerBundleURL(Assertions.assertNotNull(mJSAppBundleName)); reloadJSFromServer(bundleURL); &#125; &#125; 可以看到这个方法主要是在取bundleURL，还区分了debug js remotely模式，可以看到这里的mJSAppBundleName是在构造函里数获取的，然后构造函数用IDE的函数跳转功能并不能找到在哪里构造的，仔细观察DevSupportManagerImpl的接口DevSupportManager，可以看到在DevSupportManagerFactory这个工厂类中有使用，这里是用的反射进行构造的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static DevSupportManager create( Context applicationContext, ReactInstanceManagerDevHelper reactInstanceManagerHelper, // 这个是mJSAppBundleName @Nullable String packagerPathForJSBundleName, boolean enableOnCreate, @Nullable RedBoxHandler redBoxHandler, @Nullable DevBundleDownloadListener devBundleDownloadListener, int minNumShakes) &#123; if (!enableOnCreate) &#123; return new DisabledDevSupportManager(); &#125; try &#123; // ProGuard is surprisingly smart in this case and will keep a class if it detects a call to // Class.forName() with a static string. So instead we generate a quasi-dynamic string to // confuse it. String className = new StringBuilder(DEVSUPPORT_IMPL_PACKAGE) .append(\".\") .append(DEVSUPPORT_IMPL_CLASS) .toString(); Class&lt;?&gt; devSupportManagerClass = Class.forName(className); Constructor constructor = devSupportManagerClass.getConstructor( Context.class, ReactInstanceManagerDevHelper.class, String.class, boolean.class, RedBoxHandler.class, DevBundleDownloadListener.class, int.class); return (DevSupportManager) constructor.newInstance( applicationContext, reactInstanceManagerHelper, packagerPathForJSBundleName, true, redBoxHandler, devBundleDownloadListener, minNumShakes); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Requested enabled DevSupportManager, but DevSupportManagerImpl class was not found\" + \" or could not be created\", e); &#125; &#125; 跟到最后可以发现是在ReactNativeHost这个抽象类的getJSMainModuleName()方法拿到的，这个方法可以给用户重写进行自定义，再回到handleReloadJS方法，拼接出来的bundleURL长这样http://localhost:8081/index.delta?platform=android&amp;dev=true&amp;minify=false，host就是我们本地Nodejs启动的服务器地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void reloadJSFromServer(final String bundleURL) &#123; ReactMarker.logMarker(ReactMarkerConstants.DOWNLOAD_START); mDevLoadingViewController.showForUrl(bundleURL); mDevLoadingViewVisible = true; final BundleDownloader.BundleInfo bundleInfo = new BundleDownloader.BundleInfo(); // 触发下载任务 mDevServerHelper.downloadBundleFromURL( // 侦听下载 new DevBundleDownloadListener() &#123; @Override public void onSuccess() &#123; mDevLoadingViewController.hide(); mDevLoadingViewVisible = false; synchronized (DevSupportManagerImpl.this) &#123; mBundleStatus.isLastDownloadSucess = true; mBundleStatus.updateTimestamp = System.currentTimeMillis(); &#125; if (mBundleDownloadListener != null) &#123; mBundleDownloadListener.onSuccess(); &#125; UiThreadUtil.runOnUiThread( new Runnable() &#123; @Override public void run() &#123; ReactMarker.logMarker(ReactMarkerConstants.DOWNLOAD_END, bundleInfo.toJSONString()); mReactInstanceManagerHelper.onJSBundleLoadedFromServer(); &#125; &#125;); &#125; @Override public void onProgress(@Nullable final String status, @Nullable final Integer done, @Nullable final Integer total) &#123; mDevLoadingViewController.updateProgress(status, done, total); if (mBundleDownloadListener != null) &#123; mBundleDownloadListener.onProgress(status, done, total); &#125; &#125; @Override public void onFailure(final Exception cause) &#123; mDevLoadingViewController.hide(); mDevLoadingViewVisible = false; synchronized (DevSupportManagerImpl.this) &#123; mBundleStatus.isLastDownloadSucess = false; &#125; if (mBundleDownloadListener != null) &#123; mBundleDownloadListener.onFailure(cause); &#125; FLog.e(ReactConstants.TAG, \"Unable to download JS bundle\", cause); UiThreadUtil.runOnUiThread( new Runnable() &#123; @Override public void run() &#123; if (cause instanceof DebugServerException) &#123; DebugServerException debugServerException = (DebugServerException) cause; showNewJavaError(debugServerException.getMessage(), cause); &#125; else &#123; showNewJavaError( mApplicationContext.getString(R.string.catalyst_jsload_error), cause); &#125; &#125; &#125;); &#125; &#125;, mJSBundleTempFile, bundleURL, bundleInfo); &#125; 这个方法触发了下载任务和下载成功后续的操作，跟进mDevServerHelper.downloadBundleFromUR()方法，走到BundleDownloader类的downloadBundleFromURL方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public void downloadBundleFromURL( final DevBundleDownloadListener callback, final File outputFile, final String bundleURL, final @Nullable BundleInfo bundleInfo) &#123; // 实例化okhttp请求 final Request request = new Request.Builder() .url(mBundleDeltaClient.toDeltaUrl(bundleURL)) // FIXME: there is a bug that makes MultipartStreamReader to never find the end of the // multipart message. This temporarily disables the multipart mode to work around it, // but // it means there is no progress bar displayed in the React Native overlay anymore. // .addHeader(\"Accept\", \"multipart/mixed\") .build(); mDownloadBundleFromURLCall = Assertions.assertNotNull(mClient.newCall(request)); mDownloadBundleFromURLCall.enqueue( new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; // ignore callback if call was cancelled if (mDownloadBundleFromURLCall == null || mDownloadBundleFromURLCall.isCanceled()) &#123; mDownloadBundleFromURLCall = null; return; &#125; mDownloadBundleFromURLCall = null; callback.onFailure( DebugServerException.makeGeneric( \"Could not connect to development server.\", \"URL: \" + call.request().url().toString(), e)); &#125; @Override public void onResponse(Call call, final Response response) throws IOException &#123; // ignore callback if call was cancelled if (mDownloadBundleFromURLCall == null || mDownloadBundleFromURLCall.isCanceled()) &#123; mDownloadBundleFromURLCall = null; return; &#125; mDownloadBundleFromURLCall = null; final String url = response.request().url().toString(); // Make sure the result is a multipart response and parse the boundary. String contentType = response.header(\"content-type\"); Pattern regex = Pattern.compile(\"multipart/mixed;.*boundary=\\\"([^\\\"]+)\\\"\"); Matcher match = regex.matcher(contentType); try (Response r = response) &#123; if (match.find()) &#123; processMultipartResponse( url, r, match.group(1), outputFile, bundleInfo, callback); &#125; else &#123; // In case the server doesn't support multipart/mixed responses, fallback to normal // download. processBundleResult( url, r.code(), r.headers(), Okio.buffer(r.body().source()), outputFile, bundleInfo, callback); &#125; &#125; &#125; &#125;); &#125; 先看看这个方法的形参 DevBundleDownloadListener callback：jsbundle下载回调 File outputFile：Bundle缓存地址，我这里具体为/data/data/com.socketclientrn/files/ReactNativeDevBundle.js String bundleURL：下载jsbundle的URL 再看函数具体逻辑，内部使用了okhttp进行下载，下载成功后，onResponse回调中对返回数据进行了缓存。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void processBundleResult( String url, int statusCode, Headers headers, BufferedSource body, File outputFile, BundleInfo bundleInfo, DevBundleDownloadListener callback) throws IOException &#123; // Check for server errors. If the server error has the expected form, fail with more info. if (statusCode != 200) &#123; String bodyString = body.readUtf8(); DebugServerException debugServerException = DebugServerException.parse(bodyString); if (debugServerException != null) &#123; callback.onFailure(debugServerException); &#125; else &#123; StringBuilder sb = new StringBuilder(); sb.append(\"The development server returned response error code: \").append(statusCode).append(\"\\n\\n\") .append(\"URL: \").append(url).append(\"\\n\\n\") .append(\"Body:\\n\") .append(bodyString); callback.onFailure(new DebugServerException(sb.toString())); &#125; return; &#125; if (bundleInfo != null) &#123; populateBundleInfo(url, headers, bundleInfo); &#125; File tmpFile = new File(outputFile.getPath() + \".tmp\"); boolean bundleUpdated; if (BundleDeltaClient.isDeltaUrl(url)) &#123; // If the bundle URL has the delta extension, we need to use the delta patching logic. bundleUpdated = mBundleDeltaClient.storeDeltaInFile(body, tmpFile); &#125; else &#123; mBundleDeltaClient.reset(); bundleUpdated = storePlainJSInFile(body, tmpFile); &#125; if (bundleUpdated) &#123; // If we have received a new bundle from the server, move it to its final destination. if (!tmpFile.renameTo(outputFile)) &#123; throw new IOException(\"Couldn't rename \" + tmpFile + \" to \" + outputFile); &#125; &#125; callback.onSuccess(); &#125; 内部具体的流操作使用了okio，具体缓存的时候在参数outputFile后面加了个.tmp然后进行存储，存储ok后回调DevBundleDownloadListener。再回到DevSupportManagerImpl的reloadJSFromServer方法，可以在onSuccess回调中看到判空mBundleDownloadListener然后调用的逻辑，这个回调是初始化DevSupportManagerImpl传进来的，调用链跟到最后是在ReactNativeHost的createReactInstanceManager方法中构建ReactInstanceManager时传递的，这个方法开发者是可以重写的，提供给开发者侦听jsbundle下载是否成功与失败 createCachedBundleFromNetworkLoader1234567891011121314151617181920212223private ReactInstanceManagerDevHelper createDevHelperInterface() &#123; return new ReactInstanceManagerDevHelper() &#123; @Override public void onReloadWithJSDebugger(JavaJSExecutor.Factory jsExecutorFactory) &#123; ReactInstanceManager.this.onReloadWithJSDebugger(jsExecutorFactory); &#125; @Override public void onJSBundleLoadedFromServer() &#123; ReactInstanceManager.this.onJSBundleLoadedFromServer(); &#125; @Override public void toggleElementInspector() &#123; ReactInstanceManager.this.toggleElementInspector(); &#125; @Override public @Nullable Activity getCurrentActivity() &#123; return ReactInstanceManager.this.mCurrentActivity; &#125; &#125;; &#125; 跟着调用链，最后走到了createCachedBundleFromNetworkLoader方法里123456789101112131415public static JSBundleLoader createCachedBundleFromNetworkLoader( final String sourceURL, final String cachedFileLocation) &#123; return new JSBundleLoader() &#123; @Override public String loadScript(CatalystInstanceImpl instance) &#123; try &#123; instance.loadScriptFromFile(cachedFileLocation, sourceURL, false); return sourceURL; &#125; catch (Exception e) &#123; throw DebugServerException.makeGeneric(e.getMessage(), e); &#125; &#125; &#125;; &#125; createCachedBundleFromNetworkLoader构造完JSBundleLoader后，就开始调用CatalystInstanceImpl去加载jsbundle了，CatalystInstance是Java，C，JavaScript三端通信的入口。123456/* package */ void loadScriptFromFile(String fileName, String sourceURL, boolean loadSynchronously) &#123; mSourceURL = sourceURL; jniLoadScriptFromFile(fileName, sourceURL, loadSynchronously); &#125; private native void jniLoadScriptFromFile(String fileName, String sourceURL, boolean loadSynchronously); 可以看到最终加载jsbundle是在C里面完成的 Reload总流程reload总的流程可以总结为：点击reload -&gt; DevSupportManagerImpl拼接URL，触发下载 -&gt; BundleDownloader请求服务器下载jsbundle -&gt; 回调DevSupportManagerImpl -&gt; 调用CatalystInstanceImpl通知C加载新的jsbundle Debug JS RemotelyonKeyUp先看看Debug JS Remotely的点击事件，123456789options.put( remoteJsDebugMenuItemTitle, new DevOptionHandler() &#123; @Override public void onOptionSelected() &#123; mDevSettings.setRemoteJSDebugEnabled(!mDevSettings.isRemoteJSDebugEnabled()); handleReloadJS(); &#125; &#125;); 先设置反了一下remote_js_debug这个key，使用SharedPreference存储，然后就走到handleReloadJS方法里 handleReloadJS12345678910111213if (mDevSettings.isRemoteJSDebugEnabled()) &#123; PrinterHolder.getPrinter() .logMessage(ReactDebugOverlayTags.RN_CORE, \"RNCore: load from Proxy\"); mDevLoadingViewController.showForRemoteJSEnabled(); mDevLoadingViewVisible = true; reloadJSInProxyMode(); &#125; else &#123; PrinterHolder.getPrinter() .logMessage(ReactDebugOverlayTags.RN_CORE, \"RNCore: load from Server\"); String bundleURL = mDevServerHelper.getDevServerBundleURL(Assertions.assertNotNull(mJSAppBundleName)); reloadJSFromServer(bundleURL); &#125; 这里区分了debug js remotely模式与普通开发模式，主要看看reloadJSInProxyMode方法1234567891011121314151617181920212223242526private void reloadJSInProxyMode() &#123; // When using js proxy, there is no need to fetch JS bundle as proxy executor will do that // anyway mDevServerHelper.launchJSDevtools(); JavaJSExecutor.Factory factory = new JavaJSExecutor.Factory() &#123; @Override public JavaJSExecutor create() throws Exception &#123; WebsocketJavaScriptExecutor executor = new WebsocketJavaScriptExecutor(); SimpleSettableFuture&lt;Boolean&gt; future = new SimpleSettableFuture&lt;&gt;(); executor.connect( mDevServerHelper.getWebsocketProxyURL(), getExecutorConnectCallback(future)); // TODO(t9349129) Don't use timeout try &#123; future.get(90, TimeUnit.SECONDS); return executor; &#125; catch (ExecutionException e) &#123; throw (Exception) e.getCause(); &#125; catch (InterruptedException | TimeoutException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;; mReactInstanceManagerHelper.onReloadWithJSDebugger(factory); &#125; 先调用了launchJSDevtools方法，里面仅仅做了一个简单的request，URL为http://localhost:8081/launch-js-devtools，目的应该是打开调试网页，然后实例化了一个实现JavaJSExecutor.Factory接口的匿名类，create方法会在调用recreateReactContextInBackground方法里的子线程中调用，跟进到connectInternal方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void connectInternal( String webSocketServerUrl, final JSExecutorConnectCallback callback) &#123; final JSDebuggerWebSocketClient client = new JSDebuggerWebSocketClient(); final Handler timeoutHandler = new Handler(Looper.getMainLooper()); client.connect( webSocketServerUrl, new JSDebuggerWebSocketClient.JSDebuggerCallback() &#123; // It's possible that both callbacks can fire on an error so make sure we only // dispatch results once to our callback. private boolean didSendResult = false; @Override public void onSuccess(@Nullable String response) &#123; client.prepareJSRuntime( new JSDebuggerWebSocketClient.JSDebuggerCallback() &#123; @Override public void onSuccess(@Nullable String response) &#123; timeoutHandler.removeCallbacksAndMessages(null); mWebSocketClient = client; if (!didSendResult) &#123; callback.onSuccess(); didSendResult = true; &#125; &#125; @Override public void onFailure(Throwable cause) &#123; timeoutHandler.removeCallbacksAndMessages(null); if (!didSendResult) &#123; callback.onFailure(cause); didSendResult = true; &#125; &#125; &#125;); &#125; @Override public void onFailure(Throwable cause) &#123; timeoutHandler.removeCallbacksAndMessages(null); if (!didSendResult) &#123; callback.onFailure(cause); didSendResult = true; &#125; &#125; &#125;); timeoutHandler.postDelayed( new Runnable() &#123; @Override public void run() &#123; client.closeQuietly(); callback.onFailure( new WebsocketExecutorTimeoutException( \"Timeout while connecting to remote debugger\")); &#125; &#125;, CONNECT_TIMEOUT_MS); &#125; 这里使用了websocket与本地服务器进行连接，服务器URL为：ws://localhost:8081/debugger-proxy?role=client，继续跟到JSDebuggerWebSocketClient的connect方法1234567891011121314public void connect(String url, JSDebuggerCallback callback) &#123; if (mHttpClient != null) &#123; throw new IllegalStateException(\"JSDebuggerWebSocketClient is already initialized.\"); &#125; mConnectCallback = callback; mHttpClient = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS) .readTimeout(0, TimeUnit.MINUTES) // Disable timeouts for read .build(); Request request = new Request.Builder().url(url).build(); mHttpClient.newWebSocket(request, this); &#125; 这里是使用okhttp来和本地服务器进行长连接，建立起连接后可以看到JSDebuggerWebSocketClient里onMessage，sendMessage方法与服务器通信的逻辑。这里我们先回到reloadJSInProxyMode方法，跟到onReloadWithJSDebugger方法12345678private void onReloadWithJSDebugger(JavaJSExecutor.Factory jsExecutorFactory) &#123; Log.d(ReactConstants.TAG, \"ReactInstanceManager.onReloadWithJSDebugger()\"); recreateReactContextInBackground( new ProxyJavaScriptExecutor.Factory(jsExecutorFactory), JSBundleLoader.createRemoteDebuggerBundleLoader( mDevSupportManager.getJSBundleURLForRemoteDebugging(), mDevSupportManager.getSourceUrl())); &#125; 这里逻辑与普通debug模式差不多，都是构造JSBundleLoader和JavaScriptExecutorFactory，跟到createRemoteDebuggerBundleLoader方法中 createRemoteDebuggerBundleLoader123456789101112131415161718192021222324252627282930/** * This loader is used when proxy debugging is enabled. In that case there is no point in fetching * the bundle from device as remote executor will have to do it anyway. */ public static JSBundleLoader createRemoteDebuggerBundleLoader( final String proxySourceURL, final String realSourceURL) &#123; return new JSBundleLoader() &#123; @Override public String loadScript(CatalystInstanceImpl instance) &#123; instance.setSourceURLs(realSourceURL, proxySourceURL); return realSourceURL; &#125; &#125;; &#125; /** * This API is used in situations where the JS bundle is being executed not on * the device, but on a host machine. In that case, we must provide two source * URLs for the JS bundle: One to be used on the device, and one to be used on * the remote debugging machine. * * @param deviceURL A source URL that is accessible from this device. * @param remoteURL A source URL that is accessible from the remote machine * executing the JS. */ /* package */ void setSourceURLs(String deviceURL, String remoteURL) &#123; mSourceURL = deviceURL; jniSetSourceURL(remoteURL); &#125; 可以从注释中看出，此时jsbundle也是从本地服务器下载的 跳出逻辑看看JSBundleLoader，暴露了四个方法 createAssetLoader 从asset目录中创建loader createFileLoader 从具体某个文件中创建loader createCachedBundleFromNetworkLoader 从URL中加载 createRemoteDebuggerBundleLoader 同上 所以加载JSBundle可以归类为以上三种方式 finally开头的问题是js层面的，好像跟我分析的Java层并没什么卵关系。。但是读一读源码，总归没有坏处","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"记一次RN Android端在Mobx环境下使用FlatList导致列表错乱的问题","slug":"记RN Android端在Mobx环境下使用FlatList导致列表错乱的问题","date":"2018-04-26T09:04:07.000Z","updated":"2019-03-28T13:06:27.586Z","comments":true,"path":"2018/04/26/记RN Android端在Mobx环境下使用FlatList导致列表错乱的问题/","link":"","permalink":"http://yoursite.com/2018/04/26/记RN Android端在Mobx环境下使用FlatList导致列表错乱的问题/","excerpt":"排查结果首先说下结果，以供参考github的issue有FlatList不显示的问题，表现的跟我不太一样，他们解决方案是将removeClippedSubviews={false}，我尝试了一下不适用我的场景最终找出罪魁祸首是mobx的observable变量与FlatList的data在release环境下，未关闭RN log日志所导致的冲突 解决方案1：release环境关掉日志（我是用babel的transform-remove-console插件来关闭的） 解决方案2：如果一定要开日志，FlatList的data不要给observable Array，给普通Array","text":"排查结果首先说下结果，以供参考github的issue有FlatList不显示的问题，表现的跟我不太一样，他们解决方案是将removeClippedSubviews={false}，我尝试了一下不适用我的场景最终找出罪魁祸首是mobx的observable变量与FlatList的data在release环境下，未关闭RN log日志所导致的冲突 解决方案1：release环境关掉日志（我是用babel的transform-remove-console插件来关闭的） 解决方案2：如果一定要开日志，FlatList的data不要给observable Array，给普通Array 问题描述首先问题如下：我的RN版本0.54.0，mobx3.4.1，mobx-react4.3.5 一个长度为两百多的数组只显示了二十三条，后面全是空白，继续往下划是一个无限空白的list，还伴随着闪屏现象，太可怕，更可怕的是debug包无此问题，release包却有，最怕排查这种问题，耗时耗力 解决思路当时第一反应是没做分页一次性加载太多数据导致的，因为没有想到这个接口会有这么多数据，一般也就十几二十条，随即进行了分页处理，然而并没有什么卵用，仍然是二十三条后就显示空白，再往后滑动闪屏，此时也没有其他头绪，这下子只能啃源码来看什么原因了，不过好在FlatList是纯js实现的，不需要再去啃Java代码了。首先找到FlatList.js文件，看它的render函数 通过配置legacyImplementation来选择使用MetroListView或者VirtualizedList前者是老的ListView，后者就是替代老ListView的新列表组件，官方解释这个变量是用来比较性能的，一般用不着，着重看看VirtualizedList，view出了问题首先就看看renderItem方法，下图为VirtualizedList的renderItem方法 这里就只是区分了多栏与单栏列表，我的使用场景是单栏列表，这行代码就只是给FlatList使用者回传了一个info参数，再看看info参数具体，找到VirtualizedList的代码，再找renderItem这个props在哪里调用的，下图为CellRenderer的render方法里renderItem回传参数 可以看到是在CellRenderer这个组件的render方法里调用的，传入了item，index，separators，我们要找的就是item，但是item是从props中拿到的，再找找CellRenderer在哪里使用，可以看到是在_pushCells方法中使用，_pushCells方法在VirtualizedList的render方法中调用，下图为VirtualizedList的render方法 cells作为React.cloneElement(element,[props],[...children])的第三参数，如上图代码，此时基本可以确定问题应该在这个cells参数上了，再回头看看_pushCells方法，下图为VirtualizedList的_pushCells方法 可以看到item数据是来自props的getItem方法，这个方法传入了一个data和一个ii下标，顾名思义应该就是在取单个列表的渲染数据，这个data就是FlatList的data，我们的列表数据源，再回到调用方FlatList找到getItem方法，下图为FlatList的getItem方法 这个方法只是对多栏和单栏列表取数据的逻辑做了区分，我们可以试着把取出来的数据打印出来看是否有异常，加好调试代码，再编译一个带log的release包 可以看到第23个都挺正常，到了24个就不正常了，到了28个直接抛出error了，加了调试日志之后还会crash了，所以这个数据源可能有问题，联想到我用的Mobx框架，传给data的是一个Observable Array，而非普通Array，猜测是Observable Array与FlatList在此环境下有冲突，随后将其替换成普通Array，然后打包，测试一切正常 结尾当时得出结论是FlatList和Observable Array搭配使用就会在release环境出问题，但是如果是这种结果，那问题影响面就太大了，然后发现我打的release包为了方便定位bug，将transform-remove-console这个插件屏蔽了，打开了js日志。随后我又试着关闭日志，FlatList继续使用Observable Array，然后打包，测试一切正常，然后就经过了几番测试，基本确认了问题所在，实在有点玄学，为了定位这一个bug，打了快一天的包。。当然结论不重要，重要的是解决问题过程，以后再遇到这种问题，解决起来应该更加得心应手","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"浅析JS闭包（Closure）与函数的柯里化（Currying）","slug":"浅析JS闭包（Closure）与函数的柯里化（Currying）","date":"2018-04-26T07:55:57.000Z","updated":"2019-03-28T13:06:27.585Z","comments":true,"path":"2018/04/26/浅析JS闭包（Closure）与函数的柯里化（Currying）/","link":"","permalink":"http://yoursite.com/2018/04/26/浅析JS闭包（Closure）与函数的柯里化（Currying）/","excerpt":"","text":"JS闭包闭包在程序界是一个很抽象的概念，以至于被人称为编程界的哈姆雷特，我们先来看看MDN对其的解释 Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. 闭包是一个函数，特指那些可以访问独立变量的函数（这种独立变量在本地使用，但是却定义在一个封闭的作用域），换句话说这类函数能够记忆创建它们时的环境 其实我个人理解更倾向于： 当嵌套函数的引用传递给了嵌套函数作用域之外的变量，或者对象的属性，此时就会形成一个闭包 嗯，解释的很好，但我还是不知道这是个啥那还是少废话上代码吧。。123456789function person() &#123; var name = 'ergouzi'; console.log(name);&#125;person();console.log(name);输出：//ergouzi//undefined 很普通的一个函数，正常理解函数与变量的思维就是：函数执行，定义变量，函数执行完毕，变量销毁。再来看看另一种写法1234567891011function person() &#123; var name = 'ergouzi'; var nameFunc = function() &#123; console.log(name); &#125; return nameFunc;&#125;var personFunc = person();personFunc();输出：//ergouzi 可以看到，这里即使person函数执行完毕了，但是里面的name变量却没有被销毁，这里再套用开头解释的概念，应该能理解部分了吧。咱们再来验证一下这种“被记忆的独立变量”的特性1234567891011121314151617function person() &#123; var name = 'ergouzi'; var funcObj = &#123; 'nameFunc': function () &#123; console.log(name); &#125;, 'changeFunc': function () &#123; name = 'goudanzi'; &#125; &#125; return funcObj;&#125;var funcObj = person();funcObj.changeFunc();funcObj.nameFunc();输出：//goudanzi 可以看到，我们在该独立变量的作用域外部改变了它的值，所以说明相同环境里创建的闭包函数，引用的独立变量为同一份拷贝，即同一个对象。其实用chrome调试一下就能很清楚的看到闭包函数长啥样，比如我这里的闭包函数它长这样（还长得挺漂亮的） 我们可以看到两个函数“changeFunc”，“nameFunc”，从他们的Scopes里面都能找到Closure并且创建环境都为person，记忆的独立变量都为“name”， 再来看点哦莫西罗伊的1234567891011121314151617for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i) &#125;, 0);&#125;输出：//10//10//10//10//10//10//10//10//10//10//简要解释一下输出值，因为setTimeout是异步函数，在i=0第一次循环时只是定义了第一个定时函数而并没有执行它，待到执行第一个定时函数，但此时i的值已经变了 一个普通的for循环，每次循环定义了一个定时器函数，因为没有给定时器函数的句柄传参，它只能拿到i最后的值。我们换一种“闭包”一点的写法1234567for (var i = 0; i &lt; 10; i++) &#123; setTimeout(((j) =&gt; console.log(j))(i), 0);&#125;//或者这样写for (var i = 0; i &lt; 10; i++) &#123; (j =&gt; setTimeout((j) =&gt; console.log(j), 0))(i);&#125; 这里用到了es6的箭头函数，想详细了解箭头函数请移步箭头函数这里的代码将每次循环的i值传给了一个闭包函数，此时这个闭包函数记忆了这个i的值，等到执行定时函数时，就可以正常打印出i值。 参考文档https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures 函数的柯里化什么是柯里化简单来说就是参数消元，比如我有以下代码1add = (x, y, z) =&gt; x + y + z 我们可以将它进行柯里化1add = x =&gt; y =&gt; z =&gt; x + y + z 柯里化的作用柯里化后的函数有个特点就是返回了一个新的函数，我们又可以对这个新的函数进行配置然后得到另一个新的函数，可以类比为函数的”预加载”功能，有了这个功能我们可以对通用代码进行一些封装，比如封装一个简单的请求1234567891011121314151617181920const requestFunc = headers =&gt; method =&gt; url =&gt; body =&gt; fetch(url, &#123; method, headers, body,&#125;);const request = requestFunc(&#123; 'content-Type': 'multipart/form-data', ...params,&#125;);const postRequest = request('POST');const getRequest = request('GET');const loginRequest = postRequest('https://host/package/login');const getInfoRequest = getRequest('https://host/package/user/info')// do loginloginRequest(&#123; name: 'Tom', password: '123456' &#125;).then(response =&gt; &#123;&#125;);// get infogetInfoRequest().then(response =&gt; &#123;&#125;)' 当然，还有其他的精彩应用场景，比如使用这种特性来进行逻辑解耦和中间件的配置，Redux的源码也使用了大量柯里化函数，比如applyMiddleWare就是传入一个柯里化函数作为中间件，来获取内部状态信息。有兴趣的可以去细细品味","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}